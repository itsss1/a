VLSI Practical
4-Bit Arithmetic Logic Unit:
 
CODE:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity alu_4bit is
    Port (
        a, b   : in  STD_LOGIC_VECTOR(3 downto 0);
        opcode : in  STD_LOGIC_VECTOR(2 downto 0);
        y      : out STD_LOGIC_VECTOR(4 downto 0)
    );
end alu_4bit;
architecture Behavioral of alu_4bit is
    signal as, bs, ys : STD_LOGIC_VECTOR(4 downto 0);
begin
    as <= '0' & a;
    bs <= '0' & b;
    process(as, bs, opcode)
    begin
        case opcode is
            when "000" => ys <= as + bs;          -- ADD
            when "001" => ys <= as - bs;          -- SUB
            when "010" => ys <= as and bs;        -- AND
            when "011" => ys <= as nand bs;       -- NAND
            when "100" => ys <= as xor bs;        -- XOR
            when "101" => ys <= as xnor bs;       -- XNOR
            when "110" => ys <= as or bs;         -- OR
            when others => ys <= '0' & as(3 downto 0);  -- Pass A
        end case;
    end process;
    y <= ys;
end Behavioral;


TESTBENCH
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity test is
end test;
architecture behavior of test is
    -- Component Declaration
    component alu_4bit
        Port (
            a, b   : in  STD_LOGIC_VECTOR(3 downto 0);
            opcode : in  STD_LOGIC_VECTOR(2 downto 0);
            y      : out STD_LOGIC_VECTOR(4 downto 0)
        );
    end component;
    -- Signals for interconnection
    signal a_tb, b_tb   : STD_LOGIC_VECTOR(3 downto 0);
    signal opcode_tb    : STD_LOGIC_VECTOR(2 downto 0);
    signal y_tb         : STD_LOGIC_VECTOR(4 downto 0);
begin
    -- Instantiate the Unit Under Test (UUT)
    uut: alu_4bit
        port map (
            a => a_tb,
            b => b_tb,
            opcode => opcode_tb,
            y => y_tb
        );
    -- Stimulus Process
    process
    begin
        a_tb <= "0101"; b_tb <= "0011"; opcode_tb <= "000"; wait for 10 ns;  -- ADD
        opcode_tb <= "001"; wait for 10 ns;  -- SUB
        opcode_tb <= "010"; wait for 10 ns;  -- AND
        opcode_tb <= "011"; wait for 10 ns;  -- NAND
        opcode_tb <= "100"; wait for 10 ns;  -- XOR
        opcode_tb <= "101"; wait for 10 ns;  -- XNOR
        opcode_tb <= "110"; wait for 10 ns;  -- OR
        opcode_tb <= "111"; wait for 10 ns;  -- Default / Pass A
        wait;
    end process;
end behavior;


UCF 
NET "a<0>"  LOC= "p57";
NET "a<1>"  LOC= "p52";
NET "a<2>"  LOC= "p51";
NET "a<3>"  LOC= "p50";
NET "b<0>"  LOC= "p43";
NET "b<1>"  LOC= "p42";
NET "b<2>"  LOC= "p40";
NET "b<3>"  LOC= "p39";
NET "opcode<0>"  LOC= "p36";
NET "opcode<1>"  LOC= "p35";
NET "opcode<2>"  LOC= "p34";
NET "y<0>"  LOC= "p80";
NET "y<1>"  LOC= "p79";
NET "y<2>"  LOC= "p78";
NET "y<3>"  LOC= "p77";
NET "y<4>"  LOC= "p76";

















Program for LCD CONTROLLER :
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity LCD_CONTROLLER is
    port (
        clk   : in  std_logic;
        d_out : out std_logic_vector(7 downto 0);
        rs, rw, en : out std_logic
    );
end LCD_CONTROLLER;

architecture Behavioral of LCD_CONTROLLER is
    type state_type is (
        s0, s1, s2, s3, s4, s5, s6, s7,
        s8, s9, s10, s11, s12, s13, s14, s15
    );

    signal pr_state, ns_state : state_type := s0;
    signal clk_lcd : std_logic_vector(15 downto 0) := (others => '0');
begin

    -- Clock Divider
    process(clk)
    begin
        if rising_edge(clk) then
            clk_lcd <= std_logic_vector(unsigned(clk_lcd) + 1);
        end if;
    end process;

    -- State Transition Process
    process(clk_lcd(15))
    begin
        if rising_edge(clk_lcd(15)) then
            pr_state <= ns_state;
        end if;
    end process;

    -- Output and Next-State Logic
    process(pr_state)
    begin
        case pr_state is
            when s0  => d_out <= x"38"; rs <= '0'; rw <= '0'; en <= '1'; ns_state <= s1;
            when s1  => d_out <= x"38"; rs <= '0'; rw <= '0'; en <= '0'; ns_state <= s2;
            when s2  => d_out <= x"0C"; rs <= '0'; rw <= '0'; en <= '1'; ns_state <= s3;
            when s3  => d_out <= x"0C"; rs <= '0'; rw <= '0'; en <= '0'; ns_state <= s4;
            when s4  => d_out <= x"06"; rs <= '0'; rw <= '0'; en <= '1'; ns_state <= s5;
            when s5  => d_out <= x"06"; rs <= '0'; rw <= '0'; en <= '0'; ns_state <= s6;
            when s6  => d_out <= x"01"; rs <= '0'; rw <= '0'; en <= '1'; ns_state <= s7;
            when s7  => d_out <= x"01"; rs <= '0'; rw <= '0'; en <= '0'; ns_state <= s8;
            when s8  => d_out <= x"53"; rs <= '1'; rw <= '0'; en <= '1'; ns_state <= s9;
            when s9  => d_out <= x"53"; rs <= '1'; rw <= '0'; en <= '0'; ns_state <= s10;
            when s10 => d_out <= x"49"; rs <= '1'; rw <= '0'; en <= '1'; ns_state <= s11;
            when s11 => d_out <= x"49"; rs <= '1'; rw <= '0'; en <= '0'; ns_state <= s12;
            when s12 => d_out <= x"54"; rs <= '1'; rw <= '0'; en <= '1'; ns_state <= s13;
            when s13 => d_out <= x"54"; rs <= '1'; rw <= '0'; en <= '0'; ns_state <= s14;
            when s14 => d_out <= x"53"; rs <= '1'; rw <= '0'; en <= '1'; ns_state <= s15;
            when s15 => d_out <= x"53"; rs <= '1'; rw <= '0'; en <= '0'; ns_state <= s15;
        end case;
    end process;

end Behavioral;

TESTBENCH
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity test is
end test;

architecture Behavioral of test is

    -- Component Declaration for the Unit Under Test (UUT)
    component LCD_CONTROLLER
        port (
            clk   : in  std_logic;
            d_out : out std_logic_vector(7 downto 0);
            rs, rw, en : out std_logic
        );
    end component;

    -- Testbench Signals
    signal clk_tb   : std_logic := '0';
    signal d_out_tb : std_logic_vector(7 downto 0);
    signal rs_tb, rw_tb, en_tb : std_logic;

    constant CLK_PERIOD : time := 10 ns;

begin

    -- Instantiate the UUT
    uut: LCD_CONTROLLER
        port map (
            clk   => clk_tb,
            d_out => d_out_tb,
            rs    => rs_tb,
            rw    => rw_tb,
            en    => en_tb
        );

    -- Clock Generation Process
    clk_process : process
    begin
        while true loop
            clk_tb <= '0';
            wait for CLK_PERIOD / 2;
            clk_tb <= '1';
            wait for CLK_PERIOD / 2;
        end loop;
    end process;

    -- Stimulus Process
    stim_proc: process
    begin
        -- Wait sufficient time to observe full FSM sequence
        wait for 5 ms;  
        wait;  -- stop simulation
    end process;

end Behavioral;

UCF For LCD Controller :
NET "clk"        LOC = "P181";
NET "d_out<0>"   LOC = "P167";
NET "d_out<1>"   LOC = "P166";
NET "d_out<2>"   LOC = "P165";
NET "d_out<3>"   LOC = "P162";
NET "d_out<4>"   LOC = "P161";
NET "d_out<5>"   LOC = "P156";
NET "d_out<6>"   LOC = "P155";
NET "d_out<7>"   LOC = "P154";
NET "en"         LOC = "P168";
NET "rs"         LOC = "P171";
NET "rw"         LOC = "P169";




MOD N Counter
CODE
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity counter is
    Port ( clk : in  STD_LOGIC;
           count : out  STD_LOGIC_VECTOR (3 downto 0));
end counter;

architecture Behavioral of counter is
signal s:std_logic_vector(3 downto 0):="0000";
signal s1:std_logic_vector(20 downto 0):=(others=>'0');
signal sclk:std_logic:='0';
begin
process(clk)
begin
if(clk'event and clk='1')then
s1<=s1+1;
end if;
end process;
sclk<=s1(20);

process(sclk)
begin
if(sclk'event and sclk='1')then
s<=s+1;
end if;
end process;
count<=s;  
end Behavioral;


TESTBENCH
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity test is
end test;

architecture Behavioral of test is

    -- Component Declaration
    component counter
        Port (
            clk   : in  STD_LOGIC;
            count : out STD_LOGIC_VECTOR (3 downto 0)
        );
    end component;

    -- Testbench Signals
    signal clk_tb   : std_logic := '0';
    signal count_tb : std_logic_vector(3 downto 0);

    constant CLK_PERIOD : time := 10 ns;  -- 100 MHz clock

begin

    -- Instantiate the Unit Under Test (UUT)
    uut: counter
        port map (
            clk   => clk_tb,
            count => count_tb
        );

    -- Clock generation process
    clk_process : process
    begin
        while true loop
            clk_tb <= '0';
            wait for CLK_PERIOD / 2;
            clk_tb <= '1';
            wait for CLK_PERIOD / 2;
        end loop;
    end process;

    -- Simulation process
    stim_proc: process
    begin
        -- Wait long enough to see the counter increment
        wait for 200 ms;   -- Adjust as needed (since sclk divides by 2^21)
        wait;
    end process;
end Behavioral;

UCF
NET "clk" LOC="p181";
NET "count<0>" LOC="p80";
NET "count<1>" LOC="p79";
NET "count<2>" LOC="p78";
NET "count<3>" LOC="p77";


